The service type schema is done. Now fix the remaining 5 security issues to reach production-ready status.

TASK 1: Install Helmet
bashnpm install helmet

TASK 2: Update server/index.ts (REPLACE ENTIRE FILE)
Replace Dev-Assistant/server/index.ts with:
typescriptimport express, { type Request, Response, NextFunction } from "express";
import helmet from "helmet";
import { registerRoutes } from "./routes";
import { serveStatic } from "./static";
import { createServer } from "http";
import { initSentry, getSentryHandlers } from "./lib/sentry";
import { startCalendarSync, stopCalendarSync } from "./services/scheduler";
import { wsManager } from "./services/websocket";

const app = express();
const httpServer = createServer(app);

initSentry(app);
const sentryHandlers = getSentryHandlers();
app.use(sentryHandlers.requestHandler);

declare module "http" {
  interface IncomingMessage {
    rawBody: unknown;
  }
}

// =============================================================================
// SECURITY HEADERS (Helmet)
// =============================================================================
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'", "https://fonts.googleapis.com"],
      fontSrc: ["'self'", "https://fonts.gstatic.com"],
      imgSrc: ["'self'", "data:", "https:", "blob:"],
      scriptSrc: ["'self'", "'unsafe-inline'", "'unsafe-eval'"],
      connectSrc: ["'self'", "https://api.stripe.com", "https://api.anthropic.com", "wss:", "https:"],
      frameSrc: ["'self'", "https://js.stripe.com", "https://hooks.stripe.com"],
      workerSrc: ["'self'", "blob:"],
    },
  },
  crossOriginEmbedderPolicy: false,
  crossOriginResourcePolicy: { policy: "cross-origin" },
}));

// =============================================================================
// BODY PARSING WITH SIZE LIMITS
// =============================================================================
app.use(
  express.json({
    limit: "10mb",
    verify: (req, _res, buf) => {
      req.rawBody = buf;
    },
  }),
);

app.use(express.urlencoded({ extended: false, limit: "10mb" }));

// =============================================================================
// REQUEST LOGGING
// =============================================================================
export function log(message: string, source = "express") {
  const formattedTime = new Date().toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: true,
  });
  console.log(`${formattedTime} [${source}] ${message}`);
}

app.use((req, res, next) => {
  const start = Date.now();
  const path = req.path;
  let capturedJsonResponse: Record<string, any> | undefined = undefined;

  const originalResJson = res.json;
  res.json = function (bodyJson, ...args) {
    capturedJsonResponse = bodyJson;
    return originalResJson.apply(res, [bodyJson, ...args]);
  };

  res.on("finish", () => {
    const duration = Date.now() - start;
    if (path.startsWith("/api")) {
      let logLine = `${req.method} ${path} ${res.statusCode} in ${duration}ms`;
      if (capturedJsonResponse) {
        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;
      }
      log(logLine);
    }
  });

  next();
});

// =============================================================================
// HEALTH CHECK ENDPOINTS
// =============================================================================
app.get("/health", (_req, res) => {
  res.status(200).json({ 
    status: "healthy", 
    timestamp: new Date().toISOString(),
    version: process.env.npm_package_version || "1.0.0"
  });
});

app.get("/api/health", (_req, res) => {
  res.status(200).json({ 
    status: "healthy", 
    timestamp: new Date().toISOString(),
    environment: process.env.NODE_ENV || "development",
    version: process.env.npm_package_version || "1.0.0"
  });
});

// =============================================================================
// MAIN APP INITIALIZATION
// =============================================================================
(async () => {
  await registerRoutes(httpServer, app);

  app.use(sentryHandlers.errorHandler);

  app.use((err: any, _req: Request, res: Response, _next: NextFunction) => {
    const status = err.status || err.statusCode || 500;
    const message = err.message || "Internal Server Error";

    if (process.env.NODE_ENV === "production" && status === 500) {
      res.status(status).json({ message: "Internal Server Error" });
    } else {
      res.status(status).json({ message });
    }
  });

  if (process.env.NODE_ENV === "production") {
    serveStatic(app);
  } else {
    const { setupVite } = await import("./vite");
    await setupVite(httpServer, app);
  }

  wsManager.initialize(httpServer);

  if (process.env.NODE_ENV === "production" || process.env.ENABLE_CALENDAR_SYNC === "true") {
    try {
      startCalendarSync();
      console.log("[SERVER] Background jobs started");
    } catch (error) {
      console.error("[SERVER] Failed to start background jobs:", error);
    }
  }

  process.on("SIGTERM", () => {
    console.log("[SERVER] SIGTERM received, shutting down gracefully...");
    stopCalendarSync();
    httpServer.close(() => {
      console.log("[SERVER] Server closed");
      process.exit(0);
    });
  });

  const port = parseInt(process.env.PORT || "5000", 10);
  httpServer.listen(
    {
      port,
      host: "0.0.0.0",
      reusePort: true,
    },
    () => {
      log(`serving on port ${port}`);
    },
  );
})();

TASK 3: Add SameSite Cookie
In Dev-Assistant/server/replit_integrations/auth/replitAuth.ts, find the cookie configuration (around line 35) and add sameSite: "lax":
typescriptcookie: {
  httpOnly: true,
  secure: process.env.NODE_ENV === "production",
  sameSite: "lax",  // ADD THIS LINE
  maxAge: sessionTtl,
},

TASK 4: Create Vault Encryption Module
Create new file Dev-Assistant/server/lib/vault-encryption.ts:
typescriptimport crypto from "crypto";

const ALGORITHM = "aes-256-gcm";

function getVaultKey(): Buffer {
  const secret = process.env.VAULT_ENCRYPTION_KEY || process.env.SESSION_SECRET;
  if (!secret) {
    throw new Error("VAULT_ENCRYPTION_KEY or SESSION_SECRET required");
  }
  return crypto.scryptSync(secret, "vault-salt-hndld", 32);
}

export function encryptVaultValue(plaintext: string): string {
  const key = getVaultKey();
  const iv = crypto.randomBytes(16);
  const cipher = crypto.createCipheriv(ALGORITHM, key, iv);
  
  let encrypted = cipher.update(plaintext, "utf8", "hex");
  encrypted += cipher.final("hex");
  const authTag = cipher.getAuthTag();
  
  return `${iv.toString("hex")}:${authTag.toString("hex")}:${encrypted}`;
}

export function decryptVaultValue(encryptedData: string): string {
  if (!encryptedData) return "";

  const parts = encryptedData.split(":");
  if (parts.length !== 3 || parts[0].length !== 32 || parts[1].length !== 32) {
    return encryptedData; // Not encrypted, return as-is
  }

  const key = getVaultKey();
  const [ivHex, authTagHex, encrypted] = parts;
  
  try {
    const iv = Buffer.from(ivHex, "hex");
    const authTag = Buffer.from(authTagHex, "hex");
    const decipher = crypto.createDecipheriv(ALGORITHM, key, iv);
    decipher.setAuthTag(authTag);
    
    let decrypted = decipher.update(encrypted, "hex", "utf8");
    decrypted += decipher.final("utf8");
    return decrypted;
  } catch (error) {
    console.error("[Vault] Decryption failed:", error);
    throw new Error("Failed to decrypt vault value");
  }
}

export function isEncrypted(value: string): boolean {
  if (!value) return false;
  const parts = value.split(":");
  return parts.length === 3 && parts[0].length === 32 && parts[1].length === 32;
}

TASK 5: Update Access Items Routes
In Dev-Assistant/server/routes.ts:

Add import near top:

typescriptimport { encryptVaultValue, decryptVaultValue, isEncrypted } from "./lib/vault-encryption";

Find the POST /api/access-items route and update to encrypt:

typescript// Before saving, encrypt the value
const valueToStore = encryptVaultValue(req.body.value);
const accessItem = await storage.createAccessItem({
  ...req.body,
  value: valueToStore,
  isEncrypted: true,
  householdId,
});
// Return with decrypted value for response
res.json({ ...accessItem, value: req.body.value });

Find the GET /api/access-items route and update to decrypt:

typescript// Decrypt values when returning
const decryptedItems = accessItems.map(item => ({
  ...item,
  value: item.isEncrypted ? decryptVaultValue(item.value) : item.value,
}));
res.json(decryptedItems);

Find the PATCH /api/access-items/:id route and encrypt if value changes:

typescriptif (req.body.value) {
  req.body.value = encryptVaultValue(req.body.value);
  req.body.isEncrypted = true;
}

TASK 6: Update .env.example
Add to .env.example:
bash# Vault Encryption (recommended for production)
VAULT_ENCRYPTION_KEY=your-32-char-minimum-secret-key-here

Verification
After completing all tasks:
bash# Test health endpoint
curl http://localhost:5000/health

# Check security headers
curl -I http://localhost:5000 | grep -i "x-frame\|x-content\|st
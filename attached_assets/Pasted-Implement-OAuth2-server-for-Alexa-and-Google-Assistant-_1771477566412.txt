Implement OAuth2 server for Alexa and Google Assistant account linking.

## Database Schema

Add to shared/schema.ts:

export const oauthClients = pgTable("oauth_clients", {
  id: varchar("id").primaryKey().$defaultFn(() => crypto.randomUUID()),
  clientId: varchar("client_id", { length: 100 }).notNull().unique(),
  clientSecret: text("client_secret").notNull(), // Hashed
  name: varchar("name", { length: 100 }).notNull(), // "Alexa", "Google Assistant"
  redirectUris: jsonb("redirect_uris").$type<string[]>().notNull(),
  scopes: jsonb("scopes").$type<string[]>().default(["default"]),
  isActive: boolean("is_active").default(true).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export const oauthAuthorizationCodes = pgTable("oauth_authorization_codes", {
  id: varchar("id").primaryKey().$defaultFn(() => crypto.randomUUID()),
  code: varchar("code", { length: 100 }).notNull().unique(),
  clientId: varchar("client_id").notNull(),
  userId: varchar("user_id").notNull(),
  householdId: varchar("household_id").notNull(),
  redirectUri: text("redirect_uri").notNull(),
  scope: varchar("scope", { length: 255 }),
  expiresAt: timestamp("expires_at").notNull(),
  usedAt: timestamp("used_at"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

## Server Implementation

Create server/routes/oauth.ts:

import { Router, Request, Response } from "express";
import { db } from "../db";
import { oauthClients, oauthAuthorizationCodes, apiTokens } from "@shared/schema";
import { eq, and, gt, isNull } from "drizzle-orm";
import { addMinutes, addDays } from "date-fns";
import { isAuthenticated } from "../replit_integrations/auth";
import { householdContextMiddleware } from "../middleware/householdContext";
import crypto from "crypto";
import bcrypt from "bcrypt";
import logger from "../lib/logger";

const router = Router();

// Authorization endpoint - shows consent screen
router.get("/oauth/authorize", isAuthenticated, householdContextMiddleware, async (req: Request, res: Response) => {
  try {
    const { client_id, redirect_uri, response_type, state, scope } = req.query;

    if (response_type !== "code") {
      return res.status(400).json({ error: "unsupported_response_type" });
    }

    // Validate client
    const [client] = await db.select().from(oauthClients)
      .where(and(
        eq(oauthClients.clientId, client_id as string),
        eq(oauthClients.isActive, true)
      )).limit(1);

    if (!client) {
      return res.status(400).json({ error: "invalid_client" });
    }

    // Validate redirect URI
    if (!client.redirectUris.includes(redirect_uri as string)) {
      return res.status(400).json({ error: "invalid_redirect_uri" });
    }

    // Render consent page
    res.send(`
      <!DOCTYPE html>
      <html>
        <head>
          <title>Authorize ${client.name}</title>
          <style>
            body { font-family: system-ui; max-width: 400px; margin: 50px auto; padding: 20px; }
            h1 { font-size: 24px; }
            button { padding: 12px 24px; font-size: 16px; margin: 10px 5px 10px 0; cursor: pointer; }
            .allow { background: #1D2A44; color: white; border: none; border-radius: 8px; }
            .deny { background: #eee; border: 1px solid #ccc; border-radius: 8px; }
          </style>
        </head>
        <body>
          <h1>Allow ${client.name} to access hndld?</h1>
          <p>${client.name} wants to:</p>
          <ul>
            <li>View your household information</li>
            <li>Check your cleaning schedule</li>
            <li>Manage approvals</li>
            <li>Control smart locks</li>
          </ul>
          <form method="POST" action="/api/v1/oauth/authorize">
            <input type="hidden" name="client_id" value="${client_id}" />
            <input type="hidden" name="redirect_uri" value="${redirect_uri}" />
            <input type="hidden" name="state" value="${state || ""}" />
            <input type="hidden" name="scope" value="${scope || "default"}" />
            <button type="submit" name="action" value="allow" class="allow">Allow</button>
            <button type="submit" name="action" value="deny" class="deny">Deny</button>
          </form>
        </body>
      </html>
    `);
  } catch (error) {
    logger.error("OAuth authorize error", { error: error instanceof Error ? error.message : String(error) });
    res.status(500).json({ error: "server_error" });
  }
});

// Handle authorization consent
router.post("/oauth/authorize", isAuthenticated, householdContextMiddleware, async (req: Request, res: Response) => {
  try {
    const { client_id, redirect_uri, state, scope, action } = req.body;
    const userId = req.user!.claims.sub;
    const householdId = req.householdId!;

    if (action === "deny") {
      const redirectUrl = new URL(redirect_uri);
      redirectUrl.searchParams.set("error", "access_denied");
      if (state) redirectUrl.searchParams.set("state", state);
      return res.redirect(redirectUrl.toString());
    }

    // Generate authorization code
    const code = crypto.randomBytes(32).toString("hex");
    const expiresAt = addMinutes(new Date(), 10);

    await db.insert(oauthAuthorizationCodes).values({
      code,
      clientId: client_id,
      userId,
      householdId,
      redirectUri: redirect_uri,
      scope,
      expiresAt,
    });

    // Redirect back with code
    const redirectUrl = new URL(redirect_uri);
    redirectUrl.searchParams.set("code", code);
    if (state) redirectUrl.searchParams.set("state", state);

    res.redirect(redirectUrl.toString());
  } catch (error) {
    logger.error("OAuth authorize POST error", { error: error instanceof Error ? error.message : String(error) });
    res.status(500).json({ error: "server_error" });
  }
});

// Token endpoint - exchange code for access token
router.post("/oauth/token", async (req: Request, res: Response) => {
  try {
    const { grant_type, code, redirect_uri, client_id, client_secret } = req.body;

    if (grant_type !== "authorization_code") {
      return res.status(400).json({ error: "unsupported_grant_type" });
    }

    // Validate client
    const [client] = await db.select().from(oauthClients)
      .where(eq(oauthClients.clientId, client_id)).limit(1);

    if (!client) {
      return res.status(400).json({ error: "invalid_client" });
    }

    const secretValid = await bcrypt.compare(client_secret, client.clientSecret);
    if (!secretValid) {
      return res.status(400).json({ error: "invalid_client" });
    }

    // Validate authorization code
    const [authCode] = await db.select().from(oauthAuthorizationCodes)
      .where(and(
        eq(oauthAuthorizationCodes.code, code),
        eq(oauthAuthorizationCodes.clientId, client_id),
        gt(oauthAuthorizationCodes.expiresAt, new Date()),
        isNull(oauthAuthorizationCodes.usedAt)
      )).limit(1);

    if (!authCode) {
      return res.status(400).json({ error: "invalid_grant" });
    }

    if (authCode.redirectUri !== redirect_uri) {
      return res.status(400).json({ error: "invalid_grant" });
    }

    // Mark code as used
    await db.update(oauthAuthorizationCodes)
      .set({ usedAt: new Date() })
      .where(eq(oauthAuthorizationCodes.id, authCode.id));

    // Generate access token
    const accessToken = crypto.randomBytes(32).toString("hex");
    const expiresAt = addDays(new Date(), 365); // Long-lived for voice assistants

    await db.insert(apiTokens).values({
      userId: authCode.userId,
      householdId: authCode.householdId,
      token: accessToken,
      name: client.name,
      expiresAt,
    });

    res.json({
      access_token: accessToken,
      token_type: "Bearer",
      expires_in: 31536000, // 1 year in seconds
    });
  } catch (error) {
    logger.error("OAuth token error", { error: error instanceof Error ? error.message : String(error) });
    res.status(500).json({ error: "server_error" });
  }
});

export function registerOAuthRoutes(app: Router) {
  app.use(router);
}

## Setup OAuth Clients

Create a migration or seed to add Alexa and Google as OAuth clients:

INSERT INTO oauth_clients (client_id, client_secret, name, redirect_uris, scopes) VALUES
('alexa-skill-client', '$2b$10$...hashed...', 'Amazon Alexa', 
 '["https://pitangui.amazon.com/api/skill/link/...", "https://layla.amazon.com/api/skill/link/..."]',
 '["alexa"]'),
('google-assistant-client', '$2b$10$...hashed...', 'Google Assistant',
 '["https://oauth-redirect.googleusercontent.com/r/YOUR_PROJECT_ID"]',
 '["google"]');

## Register Routes

In server/routes.ts:
import { registerOAuthRoutes } from "./routes/oauth";
registerOAuthRoutes(v1);
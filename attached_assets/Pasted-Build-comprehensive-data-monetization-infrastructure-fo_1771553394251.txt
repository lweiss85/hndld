Build comprehensive data monetization infrastructure for hndld.

## Overview

Create the infrastructure to:
1. Aggregate anonymized data across all households
2. Generate valuable insights for insurance, manufacturers, and researchers
3. Provide secure API access for data partners
4. Track usage and bill partners

---

## PHASE 1: ENHANCED DATA CAPTURE

### 1.1 Add Location Data to Households

Alter shared/schema.ts - add to households table or create householdDetails:

export const householdDetails = pgTable("household_details", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  householdId: varchar("household_id").references(() => households.id).notNull().unique(),
  
  // Location (for regional analytics)
  city: varchar("city", { length: 100 }),
  state: varchar("state", { length: 50 }),
  postalCode: varchar("postal_code", { length: 20 }),
  region: varchar("region", { length: 50 }), // "Southwest", "Northeast", "Midwest", "Southeast", "West"
  country: varchar("country", { length: 50 }).default("USA"),
  
  // Home characteristics (for benchmarking)
  homeType: varchar("home_type", { length: 30 }), // "SINGLE_FAMILY", "CONDO", "TOWNHOUSE", "APARTMENT", "MULTI_FAMILY"
  squareFootage: integer("square_footage"),
  bedrooms: integer("bedrooms"),
  bathrooms: numeric("bathrooms", { precision: 3, scale: 1 }),
  yearBuilt: integer("year_built"),
  lotSizeAcres: numeric("lot_size_acres", { precision: 5, scale: 2 }),
  hasPool: boolean("has_pool").default(false),
  hasHoa: boolean("has_hoa").default(false),
  
  // Household characteristics (for segmentation)
  householdSize: integer("household_size"), // number of people
  hasPets: boolean("has_pets").default(false),
  petTypes: jsonb("pet_types").$type<string[]>(), // ["DOG", "CAT", etc.]
  
  // Income bracket (optional, for premium segments)
  incomeBracket: varchar("income_bracket", { length: 30 }), // "UNDER_100K", "100K_250K", "250K_500K", "500K_PLUS"
  
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

### 1.2 Vendor Pricing Capture

export const vendorPricing = pgTable("vendor_pricing", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  vendorId: varchar("vendor_id").references(() => vendors.id).notNull(),
  householdId: varchar("household_id").references(() => households.id).notNull(),
  
  // Service details
  serviceCategory: varchar("service_category", { length: 50 }).notNull(), // "CLEANING", "LANDSCAPING", "HVAC", etc.
  serviceType: varchar("service_type", { length: 100 }), // "Deep clean", "Weekly maintenance", etc.
  
  // Pricing
  priceType: varchar("price_type", { length: 20 }).notNull(), // "HOURLY", "FLAT", "PER_SQFT", "PER_VISIT"
  priceAmountCents: integer("price_amount_cents").notNull(),
  priceCurrency: varchar("price_currency", { length: 3 }).default("USD"),
  
  // Context
  homeSquareFootage: integer("home_square_footage"), // Denormalized for analysis
  region: varchar("region", { length: 50 }), // Denormalized for fast queries
  
  // Validity
  effectiveDate: date("effective_date").notNull(),
  endDate: date("end_date"),
  
  // Quality indicators
  isVerified: boolean("is_verified").default(false), // Verified against actual invoice
  invoiceId: varchar("invoice_id"), // Link to spending item if verified
  
  createdAt: timestamp("created_at").defaultNow().notNull(),
}, (table) => [
  index("vendor_pricing_category_idx").on(table.serviceCategory),
  index("vendor_pricing_region_idx").on(table.region),
  index("vendor_pricing_effective_idx").on(table.effectiveDate),
]);

### 1.3 Appliance/Inventory Events

export const inventoryEventTypeEnum = pgEnum("inventory_event_type", [
  "PURCHASED", "INSTALLED", "MAINTENANCE", "REPAIR", 
  "FAILURE", "REPLACEMENT", "DISPOSED", "WARRANTY_CLAIM"
]);

export const inventoryEvents = pgTable("inventory_events", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  inventoryItemId: varchar("inventory_item_id").references(() => inventoryItems.id).notNull(),
  householdId: varchar("household_id").references(() => households.id).notNull(),
  
  eventType: inventoryEventTypeEnum("event_type").notNull(),
  eventDate: date("event_date").notNull(),
  
  // Cost tracking
  costCents: integer("cost_cents"),
  laborCostCents: integer("labor_cost_cents"),
  partsCostCents: integer("parts_cost_cents"),
  
  // Vendor
  vendorId: varchar("vendor_id").references(() => vendors.id),
  vendorName: varchar("vendor_name", { length: 200 }), // Denormalized
  
  // Failure details (when eventType = FAILURE)
  failureReason: varchar("failure_reason", { length: 200 }),
  failureCategory: varchar("failure_category", { length: 50 }), // "MECHANICAL", "ELECTRICAL", "WEAR", "EXTERNAL"
  wasUnderWarranty: boolean("was_under_warranty"),
  warrantyCovered: boolean("warranty_covered"),
  
  // Appliance age at event (denormalized for analysis)
  applianceAgeYears: numeric("appliance_age_years", { precision: 5, scale: 2 }),
  
  // Item details (denormalized for analysis)
  itemBrand: varchar("item_brand", { length: 100 }),
  itemModel: varchar("item_model", { length: 100 }),
  itemCategory: varchar("item_category", { length: 50 }),
  
  notes: text("notes"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
}, (table) => [
  index("inventory_events_item_idx").on(table.inventoryItemId),
  index("inventory_events_type_idx").on(table.eventType),
  index("inventory_events_brand_idx").on(table.itemBrand, table.itemCategory),
  index("inventory_events_date_idx").on(table.eventDate),
]);

### 1.4 Service Quality Tracking

export const serviceQualityRatings = pgTable("service_quality_ratings", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  householdId: varchar("household_id").references(() => households.id).notNull(),
  vendorId: varchar("vendor_id").references(() => vendors.id).notNull(),
  
  // What was rated
  serviceCategory: varchar("service_category", { length: 50 }).notNull(),
  serviceDate: date("service_date").notNull(),
  relatedTaskId: varchar("related_task_id").references(() => tasks.id),
  relatedSpendingId: varchar("related_spending_id"),
  
  // Ratings (1-5 scale)
  overallRating: integer("overall_rating").notNull(),
  qualityRating: integer("quality_rating"),
  punctualityRating: integer("punctuality_rating"),
  communicationRating: integer("communication_rating"),
  valueRating: integer("value_rating"),
  
  // Outcomes
  wouldRecommend: boolean("would_recommend"),
  hadIssue: boolean("had_issue").default(false),
  issueResolved: boolean("issue_resolved"),
  
  // Context
  pricePaidCents: integer("price_paid_cents"),
  region: varchar("region", { length: 50 }),
  
  reviewText: text("review_text"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
}, (table) => [
  index("quality_vendor_idx").on(table.vendorId),
  index("quality_category_idx").on(table.serviceCategory),
  index("quality_region_idx").on(table.region),
]);

---

## PHASE 2: AGGREGATION SERVICES

### 2.1 Create Aggregate Analytics Service

Create server/services/aggregate-analytics.ts:

import { db } from "../db";
import {
  inventoryItems, inventoryEvents, vendorPricing, serviceQualityRatings,
  spendingItems, tasks, householdDetails, cleaningVisits,
} from "@shared/schema";
import { eq, and, gte, lte, sql, count, avg, min, max } from "drizzle-orm";
import logger from "../lib/logger";

const MIN_K_ANONYMITY = 10; // Minimum records before returning data

interface AggregateResult<T> {
  data: T;
  sampleSize: number;
  period?: { start: string; end: string };
  region?: string;
  meetsMinimumThreshold: boolean;
}

// Appliance lifespan by brand/model
export async function getApplianceLifespan(
  category: string,
  brand?: string,
  model?: string
): Promise<AggregateResult<{
  avgLifespanYears: number;
  medianLifespanYears: number;
  minLifespanYears: number;
  maxLifespanYears: number;
  failureRate: number; // failures per 100 units per year
  topFailureReasons: { reason: string; percentage: number }[];
}>> {
  const conditions = [
    eq(inventoryEvents.eventType, "FAILURE"),
    eq(inventoryEvents.itemCategory, category),
  ];
  
  if (brand) conditions.push(eq(inventoryEvents.itemBrand, brand));
  if (model) conditions.push(eq(inventoryEvents.itemModel, model));

  const failures = await db.select({
    avgAge: avg(inventoryEvents.applianceAgeYears),
    minAge: min(inventoryEvents.applianceAgeYears),
    maxAge: max(inventoryEvents.applianceAgeYears),
    count: count(),
  })
    .from(inventoryEvents)
    .where(and(...conditions));

  const sampleSize = Number(failures[0]?.count || 0);

  if (sampleSize < MIN_K_ANONYMITY) {
    return {
      data: null as any,
      sampleSize,
      meetsMinimumThreshold: false,
    };
  }

  // Get failure reasons
  const reasons = await db.select({
    reason: inventoryEvents.failureReason,
    count: count(),
  })
    .from(inventoryEvents)
    .where(and(...conditions))
    .groupBy(inventoryEvents.failureReason)
    .orderBy(sql`count(*) desc`)
    .limit(5);

  return {
    data: {
      avgLifespanYears: Number(failures[0]?.avgAge || 0),
      medianLifespanYears: Number(failures[0]?.avgAge || 0), // Simplified
      minLifespanYears: Number(failures[0]?.minAge || 0),
      maxLifespanYears: Number(failures[0]?.maxAge || 0),
      failureRate: 0, // Would need total installed base to calculate
      topFailureReasons: reasons.map(r => ({
        reason: r.reason || "Unknown",
        percentage: (Number(r.count) / sampleSize) * 100,
      })),
    },
    sampleSize,
    meetsMinimumThreshold: true,
  };
}

// Vendor pricing by region and category
export async function getVendorPricingBenchmarks(
  serviceCategory: string,
  region?: string,
  priceType?: string
): Promise<AggregateResult<{
  avgPriceCents: number;
  medianPriceCents: number;
  minPriceCents: number;
  maxPriceCents: number;
  percentile25: number;
  percentile75: number;
  priceByHomeSize: { sqftRange: string; avgPrice: number }[];
}>> {
  const conditions = [eq(vendorPricing.serviceCategory, serviceCategory)];
  
  if (region) conditions.push(eq(vendorPricing.region, region));
  if (priceType) conditions.push(eq(vendorPricing.priceType, priceType));

  const pricing = await db.select({
    avgPrice: avg(vendorPricing.priceAmountCents),
    minPrice: min(vendorPricing.priceAmountCents),
    maxPrice: max(vendorPricing.priceAmountCents),
    count: count(),
  })
    .from(vendorPricing)
    .where(and(...conditions));

  const sampleSize = Number(pricing[0]?.count || 0);

  if (sampleSize < MIN_K_ANONYMITY) {
    return {
      data: null as any,
      sampleSize,
      region,
      meetsMinimumThreshold: false,
    };
  }

  return {
    data: {
      avgPriceCents: Number(pricing[0]?.avgPrice || 0),
      medianPriceCents: Number(pricing[0]?.avgPrice || 0), // Simplified
      minPriceCents: Number(pricing[0]?.minPrice || 0),
      maxPriceCents: Number(pricing[0]?.maxPrice || 0),
      percentile25: 0, // Would need window functions
      percentile75: 0,
      priceByHomeSize: [], // Would need additional query
    },
    sampleSize,
    region,
    meetsMinimumThreshold: true,
  };
}

// Maintenance cost benchmarks
export async function getMaintenanceCostBenchmarks(
  category: string,
  region?: string,
  homeType?: string
): Promise<AggregateResult<{
  avgAnnualCostCents: number;
  avgCostPerSqFtCents: number;
  costByQuarter: { quarter: string; avgCost: number }[];
  topExpenseCategories: { category: string; avgCost: number; percentage: number }[];
}>> {
  // Implementation similar to above
  // Aggregate spending items by category and region
  
  const conditions = [eq(spendingItems.category, category)];
  
  // Join with householdDetails for region filtering
  // ...implementation
  
  return {
    data: {
      avgAnnualCostCents: 0,
      avgCostPerSqFtCents: 0,
      costByQuarter: [],
      topExpenseCategories: [],
    },
    sampleSize: 0,
    region,
    meetsMinimumThreshold: false,
  };
}

// Seasonal demand patterns
export async function getSeasonalDemandPatterns(
  serviceCategory: string,
  region?: string
): Promise<AggregateResult<{
  demandByMonth: { month: number; relativeIndex: number }[];
  peakMonths: number[];
  lowMonths: number[];
  yearOverYearGrowth: number;
}>> {
  // Aggregate task creation and spending by month
  // Calculate relative demand index (100 = average month)
  
  return {
    data: {
      demandByMonth: [],
      peakMonths: [],
      lowMonths: [],
      yearOverYearGrowth: 0,
    },
    sampleSize: 0,
    region,
    meetsMinimumThreshold: false,
  };
}

// Service quality benchmarks
export async function getServiceQualityBenchmarks(
  serviceCategory: string,
  region?: string
): Promise<AggregateResult<{
  avgOverallRating: number;
  avgQualityRating: number;
  avgValueRating: number;
  recommendationRate: number;
  issueRate: number;
  issueResolutionRate: number;
  ratingDistribution: { rating: number; percentage: number }[];
}>> {
  const conditions = [eq(serviceQualityRatings.serviceCategory, serviceCategory)];
  if (region) conditions.push(eq(serviceQualityRatings.region, region));

  const ratings = await db.select({
    avgOverall: avg(serviceQualityRatings.overallRating),
    avgQuality: avg(serviceQualityRatings.qualityRating),
    avgValue: avg(serviceQualityRatings.valueRating),
    count: count(),
  })
    .from(serviceQualityRatings)
    .where(and(...conditions));

  const sampleSize = Number(ratings[0]?.count || 0);

  if (sampleSize < MIN_K_ANONYMITY) {
    return {
      data: null as any,
      sampleSize,
      region,
      meetsMinimumThreshold: false,
    };
  }

  return {
    data: {
      avgOverallRating: Number(ratings[0]?.avgOverall || 0),
      avgQualityRating: Number(ratings[0]?.avgQuality || 0),
      avgValueRating: Number(ratings[0]?.avgValue || 0),
      recommendationRate: 0,
      issueRate: 0,
      issueResolutionRate: 0,
      ratingDistribution: [],
    },
    sampleSize,
    region,
    meetsMinimumThreshold: true,
  };
}

// Home operating cost benchmarks (for insurance/real estate)
export async function getHomeOperatingCostBenchmarks(
  region: string,
  homeType?: string,
  sqftRange?: { min: number; max: number }
): Promise<AggregateResult<{
  avgAnnualTotalCents: number;
  costBreakdown: {
    category: string;
    avgAnnualCents: number;
    percentage: number;
  }[];
  costPerSqFt: number;
  yearOverYearChange: number;
}>> {
  // Aggregate all spending by household, then average
  // Filter by region and home characteristics
  
  return {
    data: {
      avgAnnualTotalCents: 0,
      costBreakdown: [],
      costPerSqFt: 0,
      yearOverYearChange: 0,
    },
    sampleSize: 0,
    region,
    meetsMinimumThreshold: false,
  };
}

export {
  getApplianceLifespan,
  getVendorPricingBenchmarks,
  getMaintenanceCostBenchmarks,
  getSeasonalDemandPatterns,
  getServiceQualityBenchmarks,
  getHomeOperatingCostBenchmarks,
};

---

## PHASE 3: DATA ANONYMIZATION

### 3.1 Create Anonymization Service

Create server/services/data-anonymization.ts:

import logger from "../lib/logger";

interface AnonymizationConfig {
  kAnonymity: number; // Minimum group size
  generalizeLocation: boolean; // City -> Region
  generalizeDates: boolean; // Day -> Month
  generalizeAmounts: boolean; // Exact -> Range
  removeIdentifiers: boolean;
}

const DEFAULT_CONFIG: AnonymizationConfig = {
  kAnonymity: 10,
  generalizeLocation: true,
  generalizeDates: true,
  generalizeAmounts: false,
  removeIdentifiers: true,
};

// Fields that should NEVER be in exported data
const PII_FIELDS = [
  "email", "phone", "name", "firstName", "lastName",
  "address", "streetAddress", "fullAddress",
  "ssn", "socialSecurity", "taxId",
  "creditCard", "bankAccount",
  "password", "passwordHash",
  "ipAddress", "userAgent",
];

// Fields that are quasi-identifiers (can identify when combined)
const QUASI_IDENTIFIERS = [
  "postalCode", "zipCode", "birthDate", "exactAge",
  "exactIncome", "exactSquareFootage",
];

export function anonymizeRecord<T extends Record<string, any>>(
  record: T,
  config: AnonymizationConfig = DEFAULT_CONFIG
): Partial<T> {
  const result: Record<string, any> = {};

  for (const [key, value] of Object.entries(record)) {
    // Remove PII fields entirely
    if (config.removeIdentifiers && PII_FIELDS.some(pii => 
      key.toLowerCase().includes(pii.toLowerCase())
    )) {
      continue;
    }

    // Generalize quasi-identifiers
    if (QUASI_IDENTIFIERS.some(qi => key.toLowerCase().includes(qi.toLowerCase()))) {
      result[key] = generalizeValue(key, value, config);
      continue;
    }

    // Keep other fields
    result[key] = value;
  }

  return result as Partial<T>;
}

function generalizeValue(key: string, value: any, config: AnonymizationConfig): any {
  if (value === null || value === undefined) return null;

  // Postal code -> First 3 digits only
  if (key.toLowerCase().includes("postal") || key.toLowerCase().includes("zip")) {
    return String(value).substring(0, 3) + "XX";
  }

  // Date -> Month/Year only
  if (key.toLowerCase().includes("date") && config.generalizeDates) {
    const date = new Date(value);
    return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, "0")}`;
  }

  // Age -> Range
  if (key.toLowerCase().includes("age")) {
    const age = Number(value);
    if (age < 25) return "18-24";
    if (age < 35) return "25-34";
    if (age < 45) return "35-44";
    if (age < 55) return "45-54";
    if (age < 65) return "55-64";
    return "65+";
  }

  // Income -> Range
  if (key.toLowerCase().includes("income")) {
    const income = Number(value);
    if (income < 50000) return "UNDER_50K";
    if (income < 100000) return "50K_100K";
    if (income < 250000) return "100K_250K";
    if (income < 500000) return "250K_500K";
    return "500K_PLUS";
  }

  // Square footage -> Range
  if (key.toLowerCase().includes("sqft") || key.toLowerCase().includes("squarefootage")) {
    const sqft = Number(value);
    if (sqft < 1000) return "UNDER_1000";
    if (sqft < 1500) return "1000_1500";
    if (sqft < 2000) return "1500_2000";
    if (sqft < 2500) return "2000_2500";
    if (sqft < 3500) return "2500_3500";
    if (sqft < 5000) return "3500_5000";
    return "5000_PLUS";
  }

  return value;
}

export function checkKAnonymity<T extends Record<string, any>>(
  records: T[],
  quasiIdentifierKeys: string[],
  k: number = 10
): { passes: boolean; smallestGroup: number; groupCount: number } {
  // Group records by their quasi-identifier combination
  const groups = new Map<string, number>();

  for (const record of records) {
    const key = quasiIdentifierKeys
      .map(qiKey => String(record[qiKey] || ""))
      .join("|");
    
    groups.set(key, (groups.get(key) || 0) + 1);
  }

  const groupSizes = Array.from(groups.values());
  const smallestGroup = Math.min(...groupSizes);

  return {
    passes: smallestGroup >= k,
    smallestGroup,
    groupCount: groups.size,
  };
}

export function anonymizeDataset<T extends Record<string, any>>(
  records: T[],
  config: AnonymizationConfig = DEFAULT_CONFIG
): { data: Partial<T>[]; meetsKAnonymity: boolean; recordCount: number } {
  const anonymized = records.map(r => anonymizeRecord(r, config));

  // Check k-anonymity on common quasi-identifiers
  const kCheck = checkKAnonymity(
    anonymized,
    ["region", "homeType", "sqftRange"],
    config.kAnonymity
  );

  return {
    data: kCheck.passes ? anonymized : [],
    meetsKAnonymity: kCheck.passes,
    recordCount: records.length,
  };
}

---

## PHASE 4: DATA PARTNER API

### 4.1 Partner Management Schema

Add to shared/schema.ts:

export const dataPartnerTierEnum = pgEnum("data_partner_tier", [
  "BASIC", "PREMIUM", "ENTERPRISE", "RESEARCH"
]);

export const dataPartners = pgTable("data_partners", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  
  // Identity
  name: varchar("name", { length: 200 }).notNull(),
  companyName: varchar("company_name", { length: 200 }),
  contactEmail: varchar("contact_email", { length: 255 }).notNull(),
  contactName: varchar("contact_name", { length: 100 }),
  
  // Authentication
  apiKeyHash: varchar("api_key_hash", { length: 255 }).notNull(), // bcrypt hash
  apiKeyPrefix: varchar("api_key_prefix", { length: 10 }).notNull(), // First 8 chars for identification
  
  // Access control
  tier: dataPartnerTierEnum("tier").default("BASIC").notNull(),
  allowedEndpoints: jsonb("allowed_endpoints").$type<string[]>().default([]),
  allowedRegions: jsonb("allowed_regions").$type<string[]>(), // null = all regions
  allowedCategories: jsonb("allowed_categories").$type<string[]>(), // null = all categories
  
  // Usage limits
  monthlyRequestLimit: integer("monthly_request_limit").default(1000),
  dailyRequestLimit: integer("daily_request_limit").default(100),
  currentMonthUsage: integer("current_month_usage").default(0),
  currentDayUsage: integer("current_day_usage").default(0),
  usageResetDate: date("usage_reset_date"),
  
  // Billing
  monthlyFeeCents: integer("monthly_fee_cents").default(0),
  perRequestFeeCents: integer("per_request_fee_cents").default(0),
  stripeCustomerId: varchar("stripe_customer_id", { length: 100 }),
  
  // Status
  isActive: boolean("is_active").default(true).notNull(),
  activatedAt: timestamp("activated_at"),
  deactivatedAt: timestamp("deactivated_at"),
  deactivationReason: text("deactivation_reason"),
  
  // Contract
  contractStartDate: date("contract_start_date"),
  contractEndDate: date("contract_end_date"),
  
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
}, (table) => [
  index("data_partners_api_key_idx").on(table.apiKeyPrefix),
  index("data_partners_active_idx").on(table.isActive),
]);

export const dataApiLogs = pgTable("data_api_logs", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  partnerId: varchar("partner_id").references(() => dataPartners.id).notNull(),
  
  // Request details
  endpoint: varchar("endpoint", { length: 255 }).notNull(),
  method: varchar("method", { length: 10 }).notNull(),
  queryParams: jsonb("query_params"),
  
  // Response details
  responseStatus: integer("response_status").notNull(),
  responseTimeMs: integer("response_time_ms"),
  resultCount: integer("result_count"),
  
  // Billing
  billableUnits: integer("billable_units").default(1),
  
  // Context
  ipAddress: varchar("ip_address", { length: 45 }),
  userAgent: text("user_agent"),
  
  createdAt: timestamp("created_at").defaultNow().notNull(),
}, (table) => [
  index("data_api_logs_partner_idx").on(table.partnerId),
  index("data_api_logs_endpoint_idx").on(table.endpoint),
  index("data_api_logs_date_idx").on(table.createdAt),
]);

### 4.2 Data API Routes

Create server/routes/data-api.ts:

import { Router, Request, Response, NextFunction } from "express";
import { db } from "../db";
import { dataPartners, dataApiLogs } from "@shared/schema";
import { eq, and } from "drizzle-orm";
import bcrypt from "bcrypt";
import {
  getApplianceLifespan,
  getVendorPricingBenchmarks,
  getMaintenanceCostBenchmarks,
  getSeasonalDemandPatterns,
  getServiceQualityBenchmarks,
  getHomeOperatingCostBenchmarks,
} from "../services/aggregate-analytics";
import logger from "../lib/logger";

const router = Router();

// API Key authentication middleware
async function authenticateDataPartner(req: Request, res: Response, next: NextFunction) {
  const startTime = Date.now();
  const authHeader = req.headers.authorization;

  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    return res.status(401).json({ error: "Missing or invalid API key" });
  }

  const apiKey = authHeader.substring(7);
  const apiKeyPrefix = apiKey.substring(0, 8);

  try {
    // Find partner by prefix
    const [partner] = await db.select().from(dataPartners)
      .where(and(
        eq(dataPartners.apiKeyPrefix, apiKeyPrefix),
        eq(dataPartners.isActive, true)
      ))
      .limit(1);

    if (!partner) {
      return res.status(401).json({ error: "Invalid API key" });
    }

    // Verify full key
    const isValid = await bcrypt.compare(apiKey, partner.apiKeyHash);
    if (!isValid) {
      return res.status(401).json({ error: "Invalid API key" });
    }

    // Check usage limits
    const today = new Date().toISOString().split("T")[0];
    if (partner.usageResetDate?.toString() !== today) {
      // Reset daily usage
      await db.update(dataPartners)
        .set({ currentDayUsage: 0, usageResetDate: new Date(today) })
        .where(eq(dataPartners.id, partner.id));
      partner.currentDayUsage = 0;
    }

    if (partner.currentDayUsage >= partner.dailyRequestLimit) {
      return res.status(429).json({ error: "Daily request limit exceeded" });
    }

    if (partner.currentMonthUsage >= partner.monthlyRequestLimit) {
      return res.status(429).json({ error: "Monthly request limit exceeded" });
    }

    // Check endpoint access
    const endpoint = req.path;
    if (partner.allowedEndpoints.length > 0 && 
        !partner.allowedEndpoints.some(e => endpoint.startsWith(e))) {
      return res.status(403).json({ error: "Endpoint not allowed for your tier" });
    }

    // Attach partner to request
    (req as any).dataPartner = partner;
    (req as any).requestStartTime = startTime;

    next();
  } catch (error) {
    logger.error("Data API authentication error", {
      error: error instanceof Error ? error.message : String(error),
    });
    return res.status(500).json({ error: "Authentication failed" });
  }
}

// Log request after response
function logDataApiRequest(req: Request, res: Response, resultCount: number) {
  const partner = (req as any).dataPartner;
  const startTime = (req as any).requestStartTime;

  if (!partner) return;

  const responseTimeMs = Date.now() - startTime;

  // Update usage counters
  db.update(dataPartners)
    .set({
      currentDayUsage: partner.currentDayUsage + 1,
      currentMonthUsage: partner.currentMonthUsage + 1,
    })
    .where(eq(dataPartners.id, partner.id))
    .catch(err => logger.error("Failed to update usage", { error: err }));

  // Log the request
  db.insert(dataApiLogs)
    .values({
      partnerId: partner.id,
      endpoint: req.path,
      method: req.method,
      queryParams: req.query as any,
      responseStatus: res.statusCode,
      responseTimeMs,
      resultCount,
      ipAddress: req.ip,
      userAgent: req.headers["user-agent"],
    })
    .catch(err => logger.error("Failed to log API request", { error: err }));
}

// Apply authentication to all routes
router.use(authenticateDataPartner);

// GET /data/v1/appliance-lifespan
router.get("/appliance-lifespan", async (req: Request, res: Response) => {
  try {
    const { category, brand, model } = req.query;

    if (!category) {
      return res.status(400).json({ error: "category is required" });
    }

    const result = await getApplianceLifespan(
      category as string,
      brand as string | undefined,
      model as string | undefined
    );

    if (!result.meetsMinimumThreshold) {
      logDataApiRequest(req, res, 0);
      return res.status(404).json({
        error: "Insufficient data",
        message: "Not enough records to provide anonymized results",
        sampleSize: result.sampleSize,
        minimumRequired: 10,
      });
    }

    logDataApiRequest(req, res, result.sampleSize);
    res.json(result);
  } catch (error) {
    logger.error("Appliance lifespan API error", {
      error: error instanceof Error ? error.message : String(error),
    });
    res.status(500).json({ error: "Internal server error" });
  }
});

// GET /data/v1/vendor-pricing
router.get("/vendor-pricing", async (req: Request, res: Response) => {
  try {
    const { serviceCategory, region, priceType } = req.query;

    if (!serviceCategory) {
      return res.status(400).json({ error: "serviceCategory is required" });
    }

    // Check region access
    const partner = (req as any).dataPartner;
    if (partner.allowedRegions && region && 
        !partner.allowedRegions.includes(region as string)) {
      return res.status(403).json({ error: "Region not allowed for your tier" });
    }

    const result = await getVendorPricingBenchmarks(
      serviceCategory as string,
      region as string | undefined,
      priceType as string | undefined
    );

    if (!result.meetsMinimumThreshold) {
      logDataApiRequest(req, res, 0);
      return res.status(404).json({
        error: "Insufficient data",
        sampleSize: result.sampleSize,
      });
    }

    logDataApiRequest(req, res, result.sampleSize);
    res.json(result);
  } catch (error) {
    logger.error("Vendor pricing API error", {
      error: error instanceof Error ? error.message : String(error),
    });
    res.status(500).json({ error: "Internal server error" });
  }
});

// GET /data/v1/maintenance-costs
router.get("/maintenance-costs", async (req: Request, res: Response) => {
  try {
    const { category, region, homeType } = req.query;

    if (!category) {
      return res.status(400).json({ error: "category is required" });
    }

    const result = await getMaintenanceCostBenchmarks(
      category as string,
      region as string | undefined,
      homeType as string | undefined
    );

    logDataApiRequest(req, res, result.sampleSize);
    
    if (!result.meetsMinimumThreshold) {
      return res.status(404).json({ error: "Insufficient data" });
    }

    res.json(result);
  } catch (error) {
    logger.error("Maintenance costs API error", {
      error: error instanceof Error ? error.message : String(error),
    });
    res.status(500).json({ error: "Internal server error" });
  }
});

// GET /data/v1/seasonal-demand
router.get("/seasonal-demand", async (req: Request, res: Response) => {
  try {
    const { serviceCategory, region } = req.query;

    if (!serviceCategory) {
      return res.status(400).json({ error: "serviceCategory is required" });
    }

    const result = await getSeasonalDemandPatterns(
      serviceCategory as string,
      region as string | undefined
    );

    logDataApiRequest(req, res, result.sampleSize);
    res.json(result);
  } catch (error) {
    logger.error("Seasonal demand API error", {
      error: error instanceof Error ? error.message : String(error),
    });
    res.status(500).json({ error: "Internal server error" });
  }
});

// GET /data/v1/service-quality
router.get("/service-quality", async (req: Request, res: Response) => {
  try {
    const { serviceCategory, region } = req.query;

    if (!serviceCategory) {
      return res.status(400).json({ error: "serviceCategory is required" });
    }

    const result = await getServiceQualityBenchmarks(
      serviceCategory as string,
      region as string | undefined
    );

    logDataApiRequest(req, res, result.sampleSize);
    
    if (!result.meetsMinimumThreshold) {
      return res.status(404).json({ error: "Insufficient data" });
    }

    res.json(result);
  } catch (error) {
    logger.error("Service quality API error", {
      error: error instanceof Error ? error.message : String(error),
    });
    res.status(500).json({ error: "Internal server error" });
  }
});

// GET /data/v1/home-operating-costs
router.get("/home-operating-costs", async (req: Request, res: Response) => {
  try {
    const { region, homeType, sqftMin, sqftMax } = req.query;

    if (!region) {
      return res.status(400).json({ error: "region is required" });
    }

    const result = await getHomeOperatingCostBenchmarks(
      region as string,
      homeType as string | undefined,
      sqftMin && sqftMax ? { min: Number(sqftMin), max: Number(sqftMax) } : undefined
    );

    logDataApiRequest(req, res, result.sampleSize);
    
    if (!result.meetsMinimumThreshold) {
      return res.status(404).json({ error: "Insufficient data" });
    }

    res.json(result);
  } catch (error) {
    logger.error("Home operating costs API error", {
      error: error instanceof Error ? error.message : String(error),
    });
    res.status(500).json({ error: "Internal server error" });
  }
});

export function registerDataApiRoutes(app: Router) {
  app.use("/data/v1", router);
}

---

## PHASE 5: ADMIN TOOLS FOR DATA PARTNERS

### 5.1 Add to Admin Routes

Add to server/routes/admin.ts:

// Create new data partner
router.post("/data-partners", async (req, res) => {
  const { name, companyName, contactEmail, contactName, tier, monthlyRequestLimit } = req.body;

  // Generate API key
  const apiKey = `hndld_data_${crypto.randomBytes(32).toString("hex")}`;
  const apiKeyPrefix = apiKey.substring(0, 8);
  const apiKeyHash = await bcrypt.hash(apiKey, 10);

  const [partner] = await db.insert(dataPartners).values({
    name,
    companyName,
    contactEmail,
    contactName,
    tier: tier || "BASIC",
    apiKeyHash,
    apiKeyPrefix,
    monthlyRequestLimit: monthlyRequestLimit || 1000,
    allowedEndpoints: [], // Empty = all endpoints
  }).returning();

  // Return the API key only once - it can never be retrieved again
  res.json({
    partner: { ...partner, apiKeyHash: undefined },
    apiKey, // ONLY SHOWN ONCE
    warning: "Save this API key securely. It cannot be retrieved again.",
  });
});

// List data partners
router.get("/data-partners", async (req, res) => {
  const partners = await db.select({
    id: dataPartners.id,
    name: dataPartners.name,
    companyName: dataPartners.companyName,
    tier: dataPartners.tier,
    isActive: dataPartners.isActive,
    currentMonthUsage: dataPartners.currentMonthUsage,
    monthlyRequestLimit: dataPartners.monthlyRequestLimit,
    createdAt: dataPartners.createdAt,
  }).from(dataPartners);

  res.json({ partners });
});

// Get partner usage stats
router.get("/data-partners/:id/usage", async (req, res) => {
  const { id } = req.params;
  const { days = 30 } = req.query;

  const since = subDays(new Date(), Number(days));

  const usage = await db.select({
    date: sql`DATE(${dataApiLogs.createdAt})`,
    endpoint: dataApiLogs.endpoint,
    requests: count(),
    avgResponseTime: avg(dataApiLogs.responseTimeMs),
  })
    .from(dataApiLogs)
    .where(and(
      eq(dataApiLogs.partnerId, id),
      gte(dataApiLogs.createdAt, since)
    ))
    .groupBy(sql`DATE(${dataApiLogs.createdAt})`, dataApiLogs.endpoint)
    .orderBy(sql`DATE(${dataApiLogs.createdAt})`);

  res.json({ usage });
});

---

## Register Routes

In server/routes.ts:

import { registerDataApiRoutes } from "./routes/data-api";

// Register under a separate path (not under /api/v1)
registerDataApiRoutes(app);